<%
func transformOrigin(at time)
    var anchorX = timeline.value(property: "anchorPoint.x", layer: layer.layer, time: time)
    var anchorY = timeline.value(property: "anchorPoint.y", layer: layer.layer, time: time)
    return "\(anchorX * 100)% \(anchorY * 100)%".inQuotes()
end

var keyvalues = []
var properties = ["anchorPoint.x", "anchorPoint.y"]

for property in properties
    var track = timeline.trackFor(layer: layer, property: property)
    if track != nil
        keyvalues = track.keyvaluesWithSimulatedSteps
    end
end

func timeLess(lhs, rhs) return lhs.time < rhs.time end
keyvalues = keyvalues.sorted(by: timeLess)

if !keyvalues.isEmpty
    var anchorPoints = [transformOrigin(at: 0)]
    var easings = []
    var previous = keyvalues[0]
    var time = 0

    for keyvalue in keyvalues
        if keyvalue.time == time 
            continue // Skip repeated times
        end 
        time = keyvalue.time

        anchorPoints = anchorPoints.appending(transformOrigin(at: time))
        if previous != nil
            easings = easings.appending(Web.timing(keyvalue: previous))
        end
        previous = keyvalue
    end

    var trackName = "\(id)AnchorPointAnimation"
    var querrySelector = "`${this.elementID} .\(id)`"
    var propertyName = "transformOrigins"
    var values = anchorPoints
    var timingFunctions = easings
    var times = Web.animationTimes(of: keyvalues)
    var duration = timeline.duration * 1000
    var transformOrigins = nil
    insert("js/trackConstructor.js.flt", from: Web, indentation: indentation)
end
%>