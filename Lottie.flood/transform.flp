func transform(layer, timeline, type)
    return [
        "o": opacityComponent(layer: layer, timeline: timeline, type: type),
        "r": rotationComponent(layer: layer, timeline: timeline, type: type),
        "p": positionComponent(layer: layer, timeline: timeline, type: type),
        "a": anchorPointComponent(layer: layer, timeline: timeline, type: type),
        "s": scaleComponent(layer: layer, timeline: timeline, type: type)
    ]
end

func opacityComponent(layer, timeline, type)
    if type == "composition"
        return opacityAnimation(layer: layer, timeline: timeline)
    else if type == "content" && layer.type.name == "text"
        return animation(layer: layer, propertyID: "foregroundColor.opacity", timeline: timeline)
    else
        return ["a": 0,"k": 100,"ix": 7]
    end
end

func rotationComponent(layer, timeline, type)
    switch type
    case "null":
        return  rotationAnimation(layer: layer, timeline: timeline)
    default:
        return  ["a": 0,"k": 0,"ix": 2]
    end
end

func scaleComponent(layer, timeline, type)
    if type == "content" && layer.type.name == "image"
        return [
                    "a": 0,
                    "k": [
                        xImageScale(layer: layer),
                        yImageScale(layer: layer)
                    ],
                    "ix": 2
                ]
    end

    return ["a": 0,"k": [100,100],"ix": 6]
end

func anchorPointComponent(layer, timeline, type)
    switch type
    case "null":
        return anchorPointAnimation(layer: layer, timeline: timeline)
    default:
        return ["a": 0,"k": [0,0],"ix": 1]
    end
end

func positionComponent(layer, timeline, type)
    if type == "null"
        return positionAnimation(layer: layer, timeline: timeline)
    end

    if type == "content" 
        switch layer.type.name
        case "text":
            return [
                    "a": 0,
                    "k": [
                        xTextPosition(layer: layer),
                        yTextPosition(layer: layer)
                    ],
                    "ix": 2
                ]
        case "image":
            return [
                "a": 0,
                "k": [
                    xImagePosition(layer: layer),
                    yImagePosition(layer: layer)
                ],
                "ix": 2
            ]
        end
    end

    return ["a": 0,"k": [0,0],"ix": 2]
end

func xTextPosition(layer)
    switch layer.alignment.name
    case "right":
        return 0
    case "left":
        return 0
    case "center":
        return 0
    case "justified":
        return 0
    end
end

func yTextPosition(layer)
    return layer.fontSize
end

func xImagePosition(layer)
    var imageWidth = layer.image.size.width
    var layerWidth = layer.bounds.size.width
    switch layer.contentMode.name
    case "center":
        return (layerWidth / 2) - (imageWidth / 2)
    case "top":
        return (layerWidth / 2) - (imageWidth / 2)
    case "bottom":
        return (layerWidth / 2) - (imageWidth / 2)
    case "topLeft":
        return 0
    case "left":
        return 0
    case "bottomLeft":
        return 0
    case "right":
        return layerWidth - imageWidth
    case "topRight":
        return layerWidth - imageWidth
    case "bottomRight":
        return layerWidth - imageWidth
    case "resize":
        return 0
    case "resizeAspect":
        var newImageWidth = imageWidth * xImageScale(layer: layer) / 100
        return (layerWidth / 2) - (newImageWidth / 2)
    case "resizeAspectFill":
        var newImageWidth = imageWidth * xImageScale(layer: layer) / 100
        return (layerWidth / 2) - (newImageWidth / 2)
    end
end

func yImagePosition(layer)
    var imageHeight = layer.image.size.height
    var layerHeight = layer.bounds.size.height
    switch layer.contentMode.name
    case "top":
        return 0
    case "topLeft":
        return 0
    case "topRight":
        return 0
    case "left":
        return (layerHeight / 2) - (imageHeight / 2)
    case "center":
        return (layerHeight / 2) - (imageHeight / 2)
    case "right":
        return (layerHeight / 2) - (imageHeight / 2)
    case "bottom":
        return layerHeight - imageHeight
    case "bottomLeft":
        return layerHeight - imageHeight
    case "bottomRight":
        return layerHeight - imageHeight
    case "resize":
        return 0
    case "resizeAspect":
        var newImageHeight = imageHeight * yImageScale(layer: layer) / 100
        return (layerHeight / 2) - (newImageHeight / 2)
    case "resizeAspectFill":
        var newImageHeight = imageHeight * yImageScale(layer: layer) / 100
        return (layerHeight / 2) - (newImageHeight / 2)
    end
end

func xImageScale(layer)
    var imageWidth = layer.image.size.width
    var layerWidth = layer.bounds.size.width
    var imageHeight = layer.image.size.height
    var layerHeight = layer.bounds.size.height
    var widthtRatio = layerWidth / imageWidth
    var heightRatio = layerHeight / imageHeight
    
    switch layer.contentMode.name
    case "resize":
        return 100 * layerWidth / imageWidth
    case "resizeAspect":
        return 100 * min(widthtRatio, heightRatio)
    case "resizeAspectFill":
        return 100 * max(widthtRatio, heightRatio)
    default: 
        return 100
    end
end

func yImageScale(layer)
    var imageWidth = layer.image.size.width
    var layerWidth = layer.bounds.size.width
    var imageHeight = layer.image.size.height
    var layerHeight = layer.bounds.size.height
    var widthtRatio = layerWidth / imageWidth
    var heightRatio = layerHeight / imageHeight

    switch layer.contentMode.name
    case "resize":
        return 100 * layerHeight / imageHeight
    case "resizeAspect":
        return 100 * min(widthtRatio, heightRatio)
    case "resizeAspectFill":
        return 100 * max(widthtRatio, heightRatio)
    default: 
        return 100
    end
end

func positionAnimation(layer, timeline)
    return [
        "s": true, // seperate position dimensions into x and y components in order to animate them independently
        "x": xPositionAnimation(layer: layer, timeline: timeline),
        "y": yPositionAnimation(layer: layer, timeline: timeline)
    ]
end

func min(_ lhs, _ rhs)
    if lhs < rhs
        return lhs
    else
        return rhs
    end
end

func max(_ lhs, _ rhs)
    if lhs > rhs
        return lhs
    else
        return rhs
    end
end