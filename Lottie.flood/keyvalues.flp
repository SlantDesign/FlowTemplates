func kevaluesArray(layer, propertyID, timeline)
    var tracks = tracksFor(layer: layer, propertyID: propertyID, timeline: timeline)
    if tracks.isEmpty
        return []
    end

    var keyvaluesArray = []
    for keyvalue in tracks[0].keyvaluesWithSimulatedSteps
        keyvaluesArray = keyvaluesArray.appending(keyvalueData(from: keyvalue, propertyID: propertyID))
    end

    return keyvaluesArray
end

func keyvalueData(from keyvalue, propertyID)
    return keyFrame(inX: keyvalue.trailingTimingFunction.controlPoints[1].x, 
                    inY: keyvalue.trailingTimingFunction.controlPoints[1].y, 
                    outX: keyvalue.trailingTimingFunction.controlPoints[0].x, 
                    outY: keyvalue.trailingTimingFunction.controlPoints[0].y, 
                    frame: frameNumber(from: keyvalue.time), 
                    value: keyvalueValue(from: keyvalue, propertyID: propertyID))
end

func keyFrame(inX, inY, outX, outY, frame, value)
    func array(from value)
        if value is Array
            return value
        else
            return [value]
        end
    end

    return [
        "o": [
            "x": [ outX ],
            "y": [ outY ]
        ],
        "i": [
            "x": [ inX ],
            "y": [ inY ]
        ],
        "t": frame, // frame number
        "s": array(from: value)
    ]
end

func keyvalueValue(from keyvalue, propertyID)
    var value = extractValue(from: keyvalue, propertyID: propertyID)
    return lottieValue(from: value, propertyID: propertyID)
end

func extractValue(from keyvalue, propertyID)
    var timeline = keyvalue.track.timeline
    var layer = keyvalue.track.layer

    switch propertyID
    case "combinedPath":
        var path = keyvalue.value
        var size = timeline.value(property: "size", layer: layer, time: keyvalue.time) 
        return path.render(width: size.width, height: size.height)

    case "backgroundColor.opacity":
        return keyvalue.value.alpha

    case "fillColor.opacity":
        return keyvalue.value.alpha

    case "strokeColor.opacity":
        return keyvalue.value.alpha

    case "shadowColor.opacity":
        return keyvalue.value.alpha

    case "borderColor.opacity":
        return keyvalue.value.alpha

    case "foregroundColor.opacity":
        return keyvalue.value.alpha

    case "border.size":
        var borderWidth = timeline.value(property: "borderWidth", layer: layer, time: keyvalue.time)
        var width = keyvalue.value.width - borderWidth
        var height = keyvalue.value.height - borderWidth
        return [width, height]

    case "image.position.x":
        var layerSize = timeline.value(property: "size", layer: layer, time: keyvalue.time)
        var contentMode = timeline.value(property: "contentsGravity", layer: layer, time: keyvalue.time)
        var image = timeline.value(property: "image", layer: layer, time: keyvalue.time)
        return xImagePosition(contentMode: contentMode, layerSize: layerSize, imageSize: image.size)
    case "image.position.y":
        var layerSize = timeline.value(property: "size", layer: layer, time: keyvalue.time)
        var contentMode = timeline.value(property: "contentsGravity", layer: layer, time: keyvalue.time)
        var image = timeline.value(property: "image", layer: layer, time: keyvalue.time)
        return yImagePosition(contentMode: contentMode, layerSize: layerSize, imageSize: image.size)
    case "image.scale":
        var layerSize = timeline.value(property: "size", layer: layer, time: keyvalue.time)
        var contentMode = timeline.value(property: "contentsGravity", layer: layer, time: keyvalue.time)
        var image = timeline.value(property: "image", layer: layer, time: keyvalue.time)
        return imageScale(contentMode: contentMode, layerSize: layerSize, imageSize: image.size)
    case "anchorPoint":
        var layerSize = timeline.value(property: "size", layer: layer, time: keyvalue.time)
        var anchorPointX = timeline.value(property: "anchorPoint.x", layer: layer, time: keyvalue.time)
        var anchorPointY = timeline.value(property: "anchorPoint.y", layer: layer, time: keyvalue.time)
        return [anchorPointX, anchorPointY, layerSize]
    default:
        return keyvalue.value
    end
end